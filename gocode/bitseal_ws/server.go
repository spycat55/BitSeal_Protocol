package bitsealws

import (
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"sync"
	"time"

	rtc "github.com/spycat55/BitSeal_Protocol/gocode/bitseal_rtc"
	bsweb "github.com/spycat55/BitSeal_Protocol/gocode/bitseal_web"

	"golang.org/x/net/websocket"

	ec "github.com/bsv-blockchain/go-sdk/primitives/ec"
)

// handshakeState keeps temporary info between POST /ws/handshake and subsequent GET /ws/socket.
type handshakeState struct {
	clientPub  *ec.PublicKey
	clientSalt string // 4-byte hex string from client
	serverSalt string // 4-byte hex string generated by server
	createdAt  time.Time
}

// Server bundles server private key and an in-memory map for pending sessions.
type Server struct {
	priv    *ec.PrivateKey
	pub     *ec.PublicKey
	mux     *http.ServeMux
	pending map[string]*handshakeState // keyed by nonce from Step-1
	mu      sync.Mutex

	// OnMessage 为业务回调；若不为 nil，则在收到每条消息后调用以生成响应明文。
	// 回调返回的明文会再次加密后发回客户端；若返回 nil 则表示不需要回复。
	// 若 OnMessage 本身为 nil，则 Server 默认回显收到的明文（兼容旧逻辑）。
	OnMessage func(sess *rtc.Session, plain []byte) ([]byte, error)

	// OnSession 会在成功与客户端建立 BST2 会话后立即调用，
	// 以便业务层获取 Session（例如存入连接表、提取 peerPub 等）。
	// 如不需要可保持为 nil。
	OnSession func(sess *rtc.Session)

	// OnHandshakeResponse 允许业务层在握手阶段向返回给客户端的 JSON
	// 中添加额外的键值对。若回调返回的 map 不为 nil，则其中的所有键值对
	// 将被合并进默认的 respObj 中；若键已存在则以回调结果为准。
	// 典型用法是在创建 Server 后赋值，例如：
	//   srv.OnHandshakeResponse = func(r *http.Request, clientPub *ec.PublicKey, nonce string) map[string]any {
	//       return map[string]any{"welcome": "hello"}
	//   }
	OnHandshakeResponse func(r *http.Request, clientPub *ec.PublicKey, nonce string) map[string]any
}

// NewServer creates a new BitSeal-WS server with its own ServeMux.
func NewServer(priv *ec.PrivateKey) *Server {
	srv := &Server{
		priv:    priv,
		pub:     priv.PubKey(),
		mux:     http.NewServeMux(),
		pending: make(map[string]*handshakeState),
	}
	srv.routes()
	return srv
}

func (s *Server) routes() {
	s.mux.HandleFunc("/ws/handshake", s.handleHandshake)

	// 自定义 websocket.Server 以显式允许 "BitSeal-WS.1" 子协议。
	wsServer := websocket.Server{
		Handshake: func(cfg *websocket.Config, req *http.Request) error {
			// 验证第一个子协议必须为 BitSeal-WS.1
			if len(cfg.Protocol) == 0 || strings.TrimSpace(cfg.Protocol[0]) != "BitSeal-WS.1" {
				return fmt.Errorf("unsupported subprotocol")
			}
			// 告诉库我们接受此子协议（返回给客户端的 Sec-WebSocket-Protocol）
			cfg.Protocol = []string{"BitSeal-WS.1"}
			return nil // 继续默认握手流程
		},
		Handler: websocket.Handler(s.handleSocket),
	}
	s.mux.Handle("/ws/socket", &wsServer)
}

// ServeHTTP implements http.Handler so Server can be passed to http.ListenAndServe.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	s.mux.ServeHTTP(w, r)
}

// --- Step-1: HTTPS POST /ws/handshake ---
func (s *Server) handleHandshake(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}
	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	bodyStr := string(bodyBytes)

	// Convert headers into simple map[string]string expected by helper.
	hdr := map[string]string{
		"X-BKSA-Protocol":  r.Header.Get("X-BKSA-Protocol"),
		"X-BKSA-Sig":       r.Header.Get("X-BKSA-Sig"),
		"X-BKSA-Timestamp": r.Header.Get("X-BKSA-Timestamp"),
		"X-BKSA-Nonce":     r.Header.Get("X-BKSA-Nonce"),
	}

	// debug log for incoming handshake
	log.Printf("[BitSeal-WS] handshake POST from %s", r.RemoteAddr)

	clientPub, saltC, nonce, err := VerifyHandshakeRequest(bodyStr, r.Method, r.URL.Path, hdr, s.priv)
	if err != nil {
		log.Printf("[BitSeal-WS] handshake verify failed: %v", err)
		w.WriteHeader(http.StatusUnauthorized)
		_, _ = w.Write([]byte("verify failed"))
		return
	}

	// Generate 4-byte server salt
	saltS, _ := randomSalt4()
	log.Printf("[handshake] serverSalt %s", saltS)

	// Build JWT
	claims := map[string]any{
		"addr":   fmt.Sprintf("pk:%x", clientPub.Compressed()), // placeholder address derivation
		"salt_s": saltS,
		"nonce":  nonce,
	}
	token, err := CreateToken(claims, s.priv, 60)
	if err != nil {
		log.Printf("[BitSeal-WS] create token error: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	respObj := map[string]any{
		"token":  token,
		"salt_s": saltS,
		"ts":     time.Now().UnixMilli(),
		"nonce":  nonce,
	}

	// OnHandshakeResponse 允许业务层在握手阶段向返回给客户端的 JSON
	// 中添加额外的键值对。若回调返回的 map 不为 nil，则其中的所有键值对
	// 将被合并进默认的 respObj 中；若键已存在则以回调结果为准。
	// 典型用法是在创建 Server 后赋值，例如：
	//   srv.OnHandshakeResponse = func(r *http.Request, clientPub *ec.PublicKey, nonce string) map[string]any {
	//       return map[string]any{"welcome": "hello"}
	//   }
	if s.OnHandshakeResponse != nil {
		extra := s.OnHandshakeResponse(r, clientPub, nonce)
		for k, v := range extra {
			respObj[k] = v // overwrite if duplicated key
		}
	}

	respBody, _ := json.Marshal(respObj)

	// Sign response headers with serverPriv and clientPub (reuse BitSeal-WEB algo)
	respHeaders, err := bsweb.SignRequest("POST", "/ws/handshake", "", string(respBody), s.priv, clientPub)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	for k, v := range respHeaders {
		w.Header().Set(k, v)
	}
	w.Header().Set("Content-Type", "application/json")

	// Remember state keyed by nonce for later Upgrade validation
	s.mu.Lock()
	s.pending[nonce] = &handshakeState{clientPub: clientPub, clientSalt: saltC, serverSalt: saltS, createdAt: time.Now()}
	s.mu.Unlock()

	_, _ = w.Write(respBody)

	log.Printf("[BitSeal-WS] handshake success nonce=%s client=%x", nonce, clientPub.Compressed())
}

// --- Step-2: WebSocket Upgrade /ws/socket ---
func (s *Server) handleSocket(ws *websocket.Conn) {
	// Before Upgrade, the http.Handler satisfied checks; now inside ws request we can access headers.
	// The Authorization header is available via ws.Request().
	req := ws.Request()
	protos := strings.Split(req.Header.Get("Sec-WebSocket-Protocol"), ",")
	if len(protos) < 2 {
		_ = ws.Close()
		return
	}
	protoName := strings.TrimSpace(protos[0])
	if protoName != "BitSeal-WS.1" {
		_ = ws.Close()
		return
	}
	token := strings.TrimSpace(protos[1])

	// debug log for incoming websocket upgrade
	log.Printf("[BitSeal-WS] websocket upgrade from %s", req.RemoteAddr)

	claims, err := VerifyToken(token, s.pub)
	if err != nil {
		log.Printf("[BitSeal-WS] token verify failed: %v", err)
		_ = ws.Close()
		return
	}

	nonceVal, ok := claims["nonce"].(string)
	if !ok {
		_ = ws.Close()
		return
	}

	// lookup handshake state
	s.mu.Lock()
	state, ok := s.pending[nonceVal]
	if ok {
		delete(s.pending, nonceVal) // one-time use
	}
	s.mu.Unlock()
	if !ok {
		log.Printf("[BitSeal-WS] nonce %s not found in pending map", nonceVal)
		_ = ws.Close()
		return
	}

	// Build BST2 session
	sess, err := rtc.NewSession(s.priv, state.clientPub, bytesFromHex(state.serverSalt), bytesFromHex(state.clientSalt))
	if err != nil {
		log.Printf("[BitSeal-WS] session creation failed: %v", err)
		_ = ws.Close()
		return
	}

	log.Printf("[BitSeal-WS] session established with client %x", state.clientPub.Compressed())

	// 通知业务层新建会话
	if s.OnSession != nil {
		s.OnSession(sess)
	}

	// 强制后续发送使用 BinaryFrame，避免客户端误解为文本
	ws.PayloadType = websocket.BinaryFrame

	// Simple echo loop: decrypt incoming, print log, then echo back.
	buf := make([]byte, 1024*64)
	for {
		n, err := ws.Read(buf)
		if err != nil {
			break
		}
		frame := buf[:n]
		plain, err := sess.DecodeRecord(frame)
		if err != nil {
			log.Printf("[BitSeal-WS] decode error: %v", err)
			continue // skip invalid
		}
		log.Printf("[BitSeal-WS] recv: %d bytes plain=%q", len(plain), string(plain))

		// 根据是否设置了业务回调决定如何处理消息。
		var respPlain []byte
		if s.OnMessage != nil {
			resp, err := s.OnMessage(sess, plain)
			if err != nil {
				log.Printf("[BitSeal-WS] OnMessage error: %v", err)
				continue // 跳过本条消息
			}
			respPlain = resp
		} else {
			// 默认行为：直接回显收到的明文
			respPlain = plain
		}

		if respPlain != nil {
			outFrame, _ := sess.EncodeRecord(respPlain, 0)
			log.Printf("[debug] send len=%d first16=%x", len(outFrame), outFrame[:16])
			_ = websocket.Message.Send(ws, outFrame)
		}
	}

	log.Printf("[BitSeal-WS] connection closed")
}

// Helper: 4-byte random salt hex
func randomSalt4() (string, error) {
	b := make([]byte, 4)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	return hex.EncodeToString(b), nil
}

func byteFromHexChar(c byte) byte {
	switch {
	case '0' <= c && c <= '9':
		return c - '0'
	case 'a' <= c && c <= 'f':
		return c - 'a' + 10
	case 'A' <= c && c <= 'F':
		return c - 'A' + 10
	default:
		return 0
	}
}

// Bytes utility without allocations for guaranteed 8-char hex.
func byteFromHexPair(high, low byte) byte {
	return (byteFromHexChar(high) << 4) | byteFromHexChar(low)
}

func bytes4FromHex(s string) []byte {
	if len(s) != 8 {
		return nil
	}
	out := make([]byte, 4)
	for i := 0; i < 4; i++ {
		out[i] = byteFromHexPair(s[i*2], s[i*2+1])
	}
	return out
}

func bytes8FromHex(s string) []byte {
	if len(s) != 16 {
		return nil
	}
	out := make([]byte, 8)
	for i := 0; i < 8; i++ {
		out[i] = byteFromHexPair(s[i*2], s[i*2+1])
	}
	return out
}

func bytesFromHex(s string) []byte {
	if len(s) == 8 {
		return bytes4FromHex(s)
	}
	if len(s) == 16 {
		return bytes8FromHex(s)
	}
	// fallback: use stdlib slower path
	b, _ := hex.DecodeString(s)
	return b
}
