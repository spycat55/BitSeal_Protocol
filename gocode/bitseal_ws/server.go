package bitsealws

import (
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"sync"
	"time"

	rtc "github.com/spycat55/BitSeal_Protocol/gocode/bitseal_rtc"
	bsweb "github.com/spycat55/BitSeal_Protocol/gocode/bitseal_web"

	"golang.org/x/net/websocket"

	ec "github.com/bsv-blockchain/go-sdk/primitives/ec"
)

// handshakeState keeps temporary info between POST /ws/handshake and subsequent GET /ws/socket.
type handshakeState struct {
	clientPub  *ec.PublicKey
	clientSalt string // 4-byte hex string from client
	serverSalt string // 4-byte hex string generated by server
	createdAt  time.Time
}

// Server bundles server private key and an in-memory map for pending sessions.
type Server struct {
	priv    *ec.PrivateKey
	pub     *ec.PublicKey
	mux     *http.ServeMux
	pending map[string]*handshakeState // keyed by nonce from Step-1
	mu      sync.Mutex
}

// NewServer creates a new BitSeal-WS server with its own ServeMux.
func NewServer(priv *ec.PrivateKey) *Server {
	srv := &Server{
		priv:    priv,
		pub:     priv.PubKey(),
		mux:     http.NewServeMux(),
		pending: make(map[string]*handshakeState),
	}
	srv.routes()
	return srv
}

func (s *Server) routes() {
	s.mux.HandleFunc("/ws/handshake", s.handleHandshake)
	// Use websocket.Handler to perform the Upgrade after preliminary checks
	s.mux.Handle("/ws/socket", websocket.Handler(s.handleSocket))
}

// ServeHTTP implements http.Handler so Server can be passed to http.ListenAndServe.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	s.mux.ServeHTTP(w, r)
}

// --- Step-1: HTTPS POST /ws/handshake ---
func (s *Server) handleHandshake(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}
	bodyBytes, err := io.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	bodyStr := string(bodyBytes)

	// Convert headers into simple map[string]string expected by helper.
	hdr := map[string]string{
		"X-BKSA-Protocol":  r.Header.Get("X-BKSA-Protocol"),
		"X-BKSA-Sig":       r.Header.Get("X-BKSA-Sig"),
		"X-BKSA-Timestamp": r.Header.Get("X-BKSA-Timestamp"),
		"X-BKSA-Nonce":     r.Header.Get("X-BKSA-Nonce"),
	}

	// debug log for incoming handshake
	log.Printf("[BitSeal-WS] handshake POST from %s", r.RemoteAddr)

	clientPub, saltC, nonce, err := VerifyHandshakeRequest(bodyStr, r.Method, r.URL.Path, hdr, s.priv)
	if err != nil {
		log.Printf("[BitSeal-WS] handshake verify failed: %v", err)
		w.WriteHeader(http.StatusUnauthorized)
		_, _ = w.Write([]byte("verify failed"))
		return
	}

	// Generate 4-byte server salt
	saltS, _ := randomSalt4()

	// Build JWT
	claims := map[string]any{
		"addr":   fmt.Sprintf("pk:%x", clientPub.Compressed()), // placeholder address derivation
		"salt_s": saltS,
		"nonce":  nonce,
	}
	token, err := CreateToken(claims, s.priv, 60)
	if err != nil {
		log.Printf("[BitSeal-WS] create token error: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	respObj := map[string]any{
		"token":  token,
		"salt_s": saltS,
		"ts":     time.Now().UnixMilli(),
		"nonce":  nonce,
	}
	respBody, _ := json.Marshal(respObj)

	// Sign response headers with serverPriv and clientPub (reuse BitSeal-WEB algo)
	respHeaders, err := bsweb.SignRequest("POST", "/ws/handshake", "", string(respBody), s.priv, clientPub)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	for k, v := range respHeaders {
		w.Header().Set(k, v)
	}
	w.Header().Set("Content-Type", "application/json")

	// Remember state keyed by nonce for later Upgrade validation
	s.mu.Lock()
	s.pending[nonce] = &handshakeState{clientPub: clientPub, clientSalt: saltC, serverSalt: saltS, createdAt: time.Now()}
	s.mu.Unlock()

	_, _ = w.Write(respBody)

	log.Printf("[BitSeal-WS] handshake success nonce=%s client=%x", nonce, clientPub.Compressed())
}

// --- Step-2: WebSocket Upgrade /ws/socket ---
func (s *Server) handleSocket(ws *websocket.Conn) {
	// Before Upgrade, the http.Handler satisfied checks; now inside ws request we can access headers.
	// The Authorization header is available via ws.Request().
	req := ws.Request()
	protos := strings.Split(req.Header.Get("Sec-WebSocket-Protocol"), ",")
	if len(protos) < 2 {
		_ = ws.Close()
		return
	}
	protoName := strings.TrimSpace(protos[0])
	if protoName != "BitSeal-WS.1" {
		_ = ws.Close()
		return
	}
	token := strings.TrimSpace(protos[1])

	// debug log for incoming websocket upgrade
	log.Printf("[BitSeal-WS] websocket upgrade from %s", req.RemoteAddr)

	claims, err := VerifyToken(token, s.pub)
	if err != nil {
		log.Printf("[BitSeal-WS] token verify failed: %v", err)
		_ = ws.Close()
		return
	}

	nonceVal, ok := claims["nonce"].(string)
	if !ok {
		_ = ws.Close()
		return
	}

	// lookup handshake state
	s.mu.Lock()
	state, ok := s.pending[nonceVal]
	if ok {
		delete(s.pending, nonceVal) // one-time use
	}
	s.mu.Unlock()
	if !ok {
		log.Printf("[BitSeal-WS] nonce %s not found in pending map", nonceVal)
		_ = ws.Close()
		return
	}

	// Build BST2 session
	sess, err := rtc.NewSession(s.priv, state.clientPub, bytesFromHex(state.serverSalt), bytesFromHex(state.clientSalt))
	if err != nil {
		log.Printf("[BitSeal-WS] session creation failed: %v", err)
		_ = ws.Close()
		return
	}

	log.Printf("[BitSeal-WS] session established with client %x", state.clientPub.Compressed())

	// Simple echo loop: decrypt incoming, print log, then echo back.
	buf := make([]byte, 1024*64)
	for {
		n, err := ws.Read(buf)
		if err != nil {
			break
		}
		frame := buf[:n]
		plain, err := sess.DecodeRecord(frame)
		if err != nil {
			log.Printf("[BitSeal-WS] decode error: %v", err)
			continue // skip invalid
		}
		log.Printf("[BitSeal-WS] recv: %d bytes plain=%q", len(plain), string(plain))
		outFrame, _ := sess.EncodeRecord(plain, 0)
		_ = websocket.Message.Send(ws, outFrame)
	}

	log.Printf("[BitSeal-WS] connection closed")
}

// Helper: 4-byte random salt hex
func randomSalt4() (string, error) {
	b := make([]byte, 4)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	return hex.EncodeToString(b), nil
}

func byteFromHexChar(c byte) byte {
	switch {
	case '0' <= c && c <= '9':
		return c - '0'
	case 'a' <= c && c <= 'f':
		return c - 'a' + 10
	case 'A' <= c && c <= 'F':
		return c - 'A' + 10
	default:
		return 0
	}
}

// Bytes utility without allocations for guaranteed 8-char hex.
func byteFromHexPair(high, low byte) byte {
	return (byteFromHexChar(high) << 4) | byteFromHexChar(low)
}

func bytes4FromHex(s string) []byte {
	if len(s) != 8 {
		return nil
	}
	out := make([]byte, 4)
	for i := 0; i < 4; i++ {
		out[i] = byteFromHexPair(s[i*2], s[i*2+1])
	}
	return out
}

func bytes8FromHex(s string) []byte {
	if len(s) != 16 {
		return nil
	}
	out := make([]byte, 8)
	for i := 0; i < 8; i++ {
		out[i] = byteFromHexPair(s[i*2], s[i*2+1])
	}
	return out
}

func bytesFromHex(s string) []byte {
	if len(s) == 8 {
		return bytes4FromHex(s)
	}
	if len(s) == 16 {
		return bytes8FromHex(s)
	}
	// fallback: use stdlib slower path
	b, _ := hex.DecodeString(s)
	return b
}
